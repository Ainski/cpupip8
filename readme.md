## 指令集实现
指令集直接复用了`计算机组成原理`中的设计。其中采用了如下的指令转义关系。
|指令|mips实现方式|
|-|-|
|ADD|采用add addi addiu addu|
|NOP|转义为sll \$0,\$0,0|
|HALT|创建了一条新的指令|
|LOAD|lw|
|STORE|sw|
|CMP| sltu \$rd ,\$rs ,\$rt 或者 sub \$ 0,\$rs,\$rt|
|BZ| beq \$0,\$r,\$label|
|BN| bne \$0,\$r,\$label|


## 分支指令设计

以分支指令读取作为第0个周期。
在第0个周期下，IF_ID应当直接输出PC_bobl信号为1
在第1个周期下，pc<=pc 同时 IMEM输出的指令应当是NOP


## regfile写锁设计

在指令流过regfile 的时候为将会写的寄存器上写锁。等到写回阶段，释放写锁。
写与写之间一定不会冲突，因为后来的写一定在先来的写之后。
读与写之间有可能会冲突，这个冲突会在alu或者dmem的位置重定向。
为每一个写锁设置一个定时器，定时器时长总为3，因为只有在3个周期之后才能等回这个地方的数据。定时器归0时释放写锁。
如果冲突无法通过重定向解决，则需要等待，这个时候pc停止一个周期，向ID_EX模块传送的指令变成nop指令，冒泡一次。
reglock低2位为计时器，前2位标志是alu型占用还是dmem型占用。
这个冲突在ID段被检测出来，激活detact_confict信号，pc、IMEM、IF_ID保持原来持有的pc和instr一个周期。