# 比萨塔摔鸡蛋游戏验证模型
# 设置N=10, F=6
# 最终成本结果在$20和$21中
# 只能使用指定指令：add, addi, addiu, addu, sll, halt, lw, sw, sltu, subu, bne, beq

# 初始化
main:
    # 设置存储基地址为0x10010000
    addiu $1, $0, 0x1001     # 基地址高16位
    sll $1, $1, 16           # 左移16位
    addiu $1, $1, 0x0000     # 得到0x10010000
    
    # 设置总层数N=10，耐摔值F=6
    addiu $10, $0, 10        # N=10
    sw $10, 0x0000($1)       # 存储N到0x10010000
    addiu $11, $0, 6         # F=6
    sw $11, 0x0004($1)       # 存储F到0x10010004
    
    # 加载输入参数
    lw $2, 0x0000($1)        # 加载总层数N
    lw $3, 0x0004($1)        # 加载耐摔值F
    
    # 初始化变量
    addiu $4, $0, 1          # 鸡蛋数从1开始
    addiu $5, $0, 0          # 总摔次数初始为0
    addiu $6, $0, 0          # 总上楼数m初始为0
    addiu $7, $0, 0          # 总下楼数n初始为0
    addiu $8, $0, 0          # 摔破鸡蛋数h初始为0
    addiu $9, $0, 0          # 最后状态初始为0
    
    # 二分查找算法
    addiu $10, $0, 1         # low = 1
    add  $11, $0, $2         # high = N
    
    # 初始化常数
    addiu $24, $0, 1         # 常数1，用于比较
    addiu $25, $0, 2         # 常数2，用于比较和除法
    
search_loop:
    # 检查low < high
    sltu $12, $10, $11       # 检查low < high
    beq  $12, $0, search_end # 如果low >= high，结束
    
    # 计算中间楼层mid = (low + high) / 2
    add  $12, $10, $11       # low + high
    
    # 使用循环除以2：每次减2，直到temp < 2
    addiu $13, $12, 0        # temp = low + high
    addiu $14, $0, 0         # mid = 0
    
div_loop:
    # 比较temp < 2，不能直接使用立即数
    sltu $15, $13, $25       # 检查temp < 2，使用寄存器$25中的常数2
    bne  $15, $0, div_done   # 如果temp < 2，除法完成
    subu $13, $13, $25       # temp = temp - 2
    addiu $14, $14, 1        # mid = mid + 1
    beq  $0, $0, div_loop    # 继续循环
    
div_done:
    # $14现在包含mid值
    addiu $12, $14, 0        # mid = 计算的结果
    
    # 摔鸡蛋测试
    addiu $5, $5, 1          # 总摔次数+1
    
    # 计算上楼数：mid - low
    subu $13, $12, $10
    add  $6, $6, $13         # 累加上楼数
    
    # 测试鸡蛋是否摔破：mid <= F?
    addiu $13, $3, 1         # F+1
    sltu $14, $12, $13       # mid < F+1 即 mid <= F
    beq  $14, $0, egg_broken # 如果mid > F，鸡蛋摔破
    
    # 鸡蛋未破
    addiu $9, $0, 0          # 最后状态=0
    add  $10, $0, $12        # low = mid
    addiu $10, $10, 1        # low = mid + 1
    
    # 计算下楼数：high - mid
    subu $13, $11, $12
    add  $7, $7, $13         # 累加下楼数
    beq  $0, $0, search_continue
    
egg_broken:
    # 鸡蛋摔破
    addiu $8, $8, 1          # 摔破鸡蛋数+1
    addiu $4, $4, 1          # 总鸡蛋数+1（使用新鸡蛋）
    addiu $9, $0, 1          # 最后状态=1
    add  $11, $0, $12        # high = mid
    
    # 计算下楼数：mid - low
    subu $13, $12, $10
    add  $7, $7, $13         # 累加下楼数
    
search_continue:
    beq  $0, $0, search_loop
    
search_end:
    # 最后一次测试
    addiu $5, $5, 1          # 总摔次数+1
    
    # 测试鸡蛋是否摔破：low <= F?
    addiu $12, $3, 1         # F+1
    sltu $13, $10, $12       # low < F+1 即 low <= F
    beq  $13, $0, final_broken # 如果low > F，鸡蛋摔破
    
    # 鸡蛋未破
    addiu $9, $0, 0
    beq  $0, $0, save_results
    
final_broken:
    # 鸡蛋摔破
    addiu $8, $8, 1          # 摔破鸡蛋数+1
    addiu $4, $4, 1          # 总鸡蛋数+1
    addiu $9, $0, 1          # 最后状态=1
    
save_results:
    # 保存中间结果到内存
    sw $5, 0x0008($1)        # 总摔次数
    sw $4, 0x000C($1)        # 总鸡蛋数
    sw $9, 0x0010($1)        # 最后状态
    
    # 计算成本1（物质匮乏时期：p1=2, p2=1, p3=4）
    # cost1 = m*2 + n*1 + h*4
    add  $10, $6, $6         # m * 2
    add  $11, $7, $0         # n * 1
    add  $12, $8, $8         # h * 2
    add  $12, $12, $12       # h * 4 (h*2 * 2)
    add  $20, $10, $11       # m*2 + n*1
    add  $20, $20, $12       # 总成本1
    sw   $20, 0x0014($1)     # 保存成本1
    
    # 计算成本2（人力成本增长时期：p1=4, p2=1, p3=2）
    # cost2 = m*4 + n*1 + h*2
    add  $10, $6, $6         # m * 2
    add  $10, $10, $10       # m * 4 (m*2 * 2)
    add  $11, $7, $0         # n * 1
    add  $12, $8, $8         # h * 2
    add  $21, $10, $11       # m*4 + n*1
    add  $21, $21, $12       # 总成本2
    sw   $21, 0x0018($1)     # 保存成本2
    
    addiu $30, $0, 1         # 表示所有程序结束   
    halt