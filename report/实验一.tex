\documentclass[12pt,a4paper]{article}
% 调整包加载顺序：ctex优先，避免冲突
\usepackage[UTF8]{ctex}
% 核心依赖包
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{float}
\usepackage{longtable}
\usepackage{titlesec}
% 使用更安全的代码引入方式
\usepackage{verbatim}
\usepackage{multirow}

% 页面布局
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}

% 自定义列类型
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

% 章节格式
\titleformat{\section}{\centering\Large\heiti}{第\chinese{section}部分}{1em}{}
\titleformat{\subsection}{\raggedright\large\heiti}{\chinese{subsection}.}{1em}{}

% 定义英文校名
\newcommand{\tongjiuniversityeng}{Tongji University}

% 修复封面命令
\newcommand{\MakeCover}{
  \begin{titlepage}
    \begin{center}
      \vskip 60pt
      {\fontsize{22pt}{26pt}\bfseries 同济大学计算机科学与技术学院}
      \vskip 50pt
      {\fontsize{18pt}{22pt}\bfseries 计算机系统结构课程实验总结报告}
      \vskip 50pt

      % 校徽：注释或替换为实际路径
      \includegraphics[width=0.35\textwidth]{tongji_logo.png}
      \vskip 50pt

      % 封面表格
      \begin{tabular}{L{8em}@{\hspace{1em}}C{18em}}
        {\fontsize{18pt}{22pt}\bfseries 实验名称} & \underline{\makebox[18em]{简单的流水线CPU设计与性能分析}} \\[0.8cm]
        {\fontsize{18pt}{22pt}\bfseries 学号} & \underline{\makebox[18em]{2351579}} \\[0.8cm]
        {\fontsize{18pt}{22pt}\bfseries 姓名} & \underline{\makebox[18em]{程浩然}} \\[0.8cm]
        {\fontsize{18pt}{22pt}\bfseries 专业} & \underline{\makebox[18em]{计算机科学与技术}} \\[0.8cm]
        {\fontsize{18pt}{22pt}\bfseries 授课教师} & \underline{\makebox[18em]{秦国锋}} \\[0.8cm]
        {\fontsize{18pt}{22pt}\bfseries 日期} & \underline{\makebox[18em]{\today}} \\
      \end{tabular}
      \vspace*{\fill}
    \end{center}
  \end{titlepage}
}

\begin{document}

% 生成封面
\MakeCover

% 生成目录
\tableofcontents
\newpage

\section{实验环境部署与硬件配置说明}

本实验围绕MIPS架构的5级流水线CPU展开设计，硬件平台基于Xilinx Vivado设计套件实现，核心硬件组成包括：

\begin{itemize}
\item 流水线处理器核心：划分为取指(IF)、译码(ID)、执行(EX)、访存(MEM)、写回(WB)五个阶段
\item 流水线寄存器：包含IF/ID、ID/EX、EX/MEM、MEM/WB四级流水寄存器
\item 存储模块：指令存储器(IMEM)与数据存储器(DMEM)
\item 功能部件：算术逻辑单元(ALU)、寄存器文件、分支预测单元等
\end{itemize}

实验采用ModelSim进行仿真验证，通过自动化测试脚本run\_cpu\_tests.do批量运行测试用例，完成功能与性能的验证。

\subsection{指令集实现}

本实验复用计算机组成原理课程中的指令集设计方案，指令与MIPS架构的映射关系如下表所示：

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{指令} & \textbf{MIPS实现方式} \\
\hline
ADD & 采用add、addi、addiu、addu指令实现 \\
\hline
NOP & 转义为sll \$0,\$0,0指令 \\
\hline
HALT & 自定义新增指令实现 \\
\hline
LOAD & 复用lw指令实现 \\
\hline
STORE & 复用sw指令实现 \\
\hline
CMP & 通过sltu \$rd,\$rs,\$rt或subu \$0,\$rs,\$rt指令实现 \\
\hline
BZ & 转义为beq \$0,\$r,\$label指令 \\
\hline
BN & 转义为bne \$0,\$r,\$label指令 \\
\hline
\end{tabular}
\caption{指令转义关系表}
\end{table}

设计中手绘cpu架构图如下
\begin{figure}[!htp]
\centering
\includegraphics[width=0.7\linewidth]{screenshot003}
\caption{}
\label{fig:screenshot003}
\end{figure}


\clearpage
\section{实验的总体结构}

\subsection{5级指令流水线的总体结构}

本实验实现的MIPS架构5级流水线处理器，将指令执行过程拆解为以下五个阶段，各阶段的核心功能如下：

\begin{enumerate}
\item \textbf{取指阶段(IF, Instruction Fetch)}：
  从指令存储器中读取当前PC指向的指令，并完成程序计数器的自增更新。

\item \textbf{译码阶段(ID, Instruction Decode)}：
  对取指阶段获取的指令进行译码，从寄存器文件中读取操作数，并检测分支指令的跳转条件。

\item \textbf{执行阶段(EX, Execute)}：
  在算术逻辑单元ALU中执行译码后的运算操作，同时计算内存访问的有效地址。

\item \textbf{访存阶段(MEM, Memory Access)}：
  根据执行阶段的结果，完成数据存储器的读/写操作，实现数据的访存交互。

\item \textbf{写回阶段(WB, Write Back)}：
  将执行结果或访存数据写回寄存器文件，完成指令的最终执行流程。
\end{enumerate}

\section{总体架构部件的解释说明}

\subsection{5级指令流水线总体结构部件的解释说明}

\subsubsection{IF/ID寄存器}
IF/ID寄存器作为取指与译码阶段的衔接部件，主要用于暂存从IF阶段传递至ID阶段的关键信息，具体包括：
\begin{itemize}
\item 取指阶段获取的指令编码
\item 当前程序计数器PC的数值
\item 分支指令的目标PC地址
\end{itemize}

\subsubsection{ID/EX寄存器}
ID/EX寄存器承担译码与执行阶段的信息传递功能，暂存的核心数据包括：
\begin{itemize}
\item 译码后的指令操作码与操作数信息
\item 从寄存器文件中读取的操作数A和操作数B
\item 控制单元生成的ALU运算控制信号
\end{itemize}

\subsubsection{EX/MEM寄存器}
EX/MEM寄存器连接执行与访存阶段，主要存储执行阶段的运算结果与访存控制信息，包括：
\begin{itemize}
\item ALU的运算结果与内存访问地址
\item 数据存储器的读/写控制信号
\item 待写入数据存储器的原始数据
\end{itemize}

\subsubsection{MEM/WB寄存器}
MEM/WB寄存器是访存与写回阶段的桥梁，暂存的信息用于完成最终的写回操作，包括：
\begin{itemize}
\item 数据存储器的读取结果
\item 待写入寄存器文件的目标寄存器地址
\item 寄存器写回的使能控制信号
\end{itemize}


\clearpage
\subsection{分支预测与冲突处理机制}
\subsubsection{分支指令设计}

分支指令的执行周期以指令读取为第0周期，具体处理逻辑为：
\begin{itemize}
\item 第0周期：IF\_ID寄存器直接输出PC\_bobl信号为1，触发分支检测
\item 第1周期：程序计数器PC保持当前值不变，同时指令存储器IMEM输出NOP指令，插入流水线气泡
\end{itemize}
\subsubsection{分支指令处理}
分支指令的流水线处理机制以指令读取为第0周期，具体逻辑为：
\begin{itemize}
\item 第0周期：IF\_ID寄存器直接输出PC\_bobl信号为1，触发分支检测逻辑
\item 第1周期：程序计数器PC保持当前值，指令存储器IMEM输出NOP指令，插入流水线气泡
\end{itemize}

\subsubsection{冲突检测与处理}
流水线冲突的检测与处理流程如下：
\begin{enumerate}
\item 当检测到流水线冲突时，PC暂停一个时钟周期更新，向ID\_EX模块传递NOP指令，完成一次流水线冒泡
\item 冲突检测在译码(ID)阶段完成，检测到冲突后激活detect\_confict信号
\item PC、指令存储器IMEM与IF/ID寄存器在冲突周期内保持原有PC值与指令内容，确保流水线稳定
\end{enumerate}

\subsection{写锁设计机制}

寄存器文件的写锁设计是解决流水线数据冲突的核心机制，具体实现逻辑如下：

\begin{enumerate}
\item 当指令流经寄存器文件时，为待写入的寄存器添加写锁，直至写回阶段完成后释放写锁
\item 写操作之间不存在冲突，因为后发的写指令必然在先行的写指令之后执行
\item 读操作与写操作可能产生冲突，此类冲突需在ALU或DMEM模块中通过数据重定向解决
\item 为每个写锁配置时长为3的定时器，定时器归零时自动释放写锁（因数据需3个周期完成传递）
\item 若冲突无法通过重定向解决，则暂停PC更新一个周期，向ID\_EX模块传递NOP指令，完成一次流水线冒泡
\item 写锁寄存器reglock的低2位为计时器，高2位标识锁的类型（ALU型占用或DMEM型占用）
\item 冲突检测在译码(ID)阶段完成，检测到冲突后激活detact\_confict信号，PC、IMEM与IF/ID寄存器保持原有值一个周期
\end{enumerate}

\clearpage
\section{实验仿真过程}

\subsection{5级指令流水线的仿真过程}

本实验采用ModelSim工具完成流水线CPU的仿真验证，具体仿真流程分为以下步骤：

\begin{enumerate}
\item 编译所有Verilog硬件描述语言源文件，生成可仿真的模块库
\item 加载测试平台模块与待测CPU核心模块，建立仿真拓扑
\item 为不同测试场景加载对应的指令序列，配置仿真激励
\item 运行仿真流程，实时记录每个时钟周期的PC值、指令内容与寄存器状态
\item 将仿真输出结果与软件参考模型的计算结果对比，验证功能正确性
\end{enumerate}

自动化测试脚本run\_cpu\_tests.do会按序执行多组测试用例，覆盖ADDI、ADDIU、LW/SW、BEQ、BNE、SLL、SUBU、SLTU等核心指令的功能验证。

\subsection{启动测试与执行过程}

根据实验配套的readme.md文档说明，通过以下指令启动仿真测试：
\begin{verbatim}
vsim -c -do "do run_cpu_tests.do; quit" >log
\end{verbatim}

该命令以批处理模式运行ModelSim，自动执行run\_cpu\_tests.do脚本并将仿真日志输出至log文件，便于后续结果分析。



\section{实验仿真的波形图及某时刻寄存器值的物理意义}
\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{screenshot004}
\caption{}
\label{fig:screenshot004}
\end{figure}

我的波形图展示了所有cpu的中间信号量的取值，因为我在设计整个cpu的时候，把所有的中间信号都通过线引出到top模块当中了。



\section{流水线CPU实验性能验证模型}

\subsection{实验性能验证模型：比萨塔摔鸡蛋游戏}

由于指令集受限，我们不得不采用纯asm编程的办法。

\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/proctest.pizza_tower.asm}
\endgroup
\clearpage
\subsection{比萨塔摔鸡蛋游戏验证模型结果分析}

根据比萨塔摔鸡蛋游戏的模拟结果，使用二分查找策略在10层建筑中测试鸡蛋耐摔值（6层），得到以下计算结果：

\subsubsection{游戏模拟参数}
\begin{itemize}
    \item 建筑高度：10层
    \item 鸡蛋耐摔值：6层
    \item 测试策略：二分查找算法
    \item 初始鸡蛋数：1个（每次摔破后补充新鸡蛋）
\end{itemize}

\subsubsection{模拟过程详细分析}
二分查找测试序列：
\begin{enumerate}
    \item \textbf{测试5层}：鸡蛋未破（$5 \leq 6$），上楼4层（从1层到5层）
    \item \textbf{测试8层}：鸡蛋摔破（$8 > 6$），上楼3层（从5层到8层），摔破1个鸡蛋
    \item \textbf{测试6层}：鸡蛋未破（$6 \leq 6$），下楼2层（从8层到6层）
    \item \textbf{测试7层}：鸡蛋摔破（$7 > 6$），上楼1层（从6层到7层），摔破1个鸡蛋
    \item \textbf{最终测试7层}：鸡蛋摔破（$7 > 6$），摔破1个鸡蛋（此步骤为确认测试，未移动楼层）
\end{enumerate}

\subsubsection{MIPS寄存器存储结果}
程序执行完毕后，结果存储在以下寄存器中：

\begin{tabular}{|c|c|l|}
\hline
\textbf{时期} & \textbf{寄存器} & \textbf{数值和含义} \\
\hline
\multirow{4}{*}{物质匮乏时期}
& \$20 & 35（总成本1：$m\times2 + n\times1 + h\times4$） \\
& \$6 & 7（总上楼层数 $m$） \\
& \$7 & 9（总下楼层数 $n$） \\
& \$8 & 3（摔破的鸡蛋总数 $h$） \\
\hline
\multirow{4}{*}{人力成本增长时期}
& \$21 & 43（总成本2：$m\times4 + n\times1 + h\times2$） \\
& \$6 & 7（总上楼层数 $m$） \\
& \$7 & 9（总下楼层数 $n$） \\
& \$8 & 3（摔破的鸡蛋总数 $h$） \\
\hline
\end{tabular}

\subsubsection{关键性能指标}
\begin{itemize}
    \item 总测试次数：5次（寄存器\$5）
    \item 总使用鸡蛋数：4个（寄存器\$4）
    \item 最后测试状态：鸡蛋摔破（寄存器\$9=1）
    \item 确定耐摔值：通过二分查找最终确定F=6
\end{itemize}

\subsubsection{成本分析结论}
人力成本增长时期的总成本（43）高于物质匮乏时期（35），主要原因是上楼成本$p_1$从2增加到4，而鸡蛋成本$p_3$从4降低到2不足以抵消这一影响。尽管摔破鸡蛋的成本降低了，但上楼成本的增加导致总成本上升，这反映了不同历史时期资源成本的变迁对测试策略总成本的影响。

\subsubsection{成本计算公式验证}
\begin{align*}
\text{成本1} &= m \times 2 + n \times 1 + h \times 4 \\
&= 7 \times 2 + 9 \times 1 + 3 \times 4 \\
&= 14 + 9 + 12 = 35 (0x23)\\
\text{成本2} &= m \times 4 + n \times 1 + h \times 2 \\
&= 7 \times 4 + 9 \times 1 + 3 \times 2 \\
&= 28 + 9 + 6 = 43 (0x2b)
\end{align*}

与寄存器\$20和\$21中的值完全一致，验证了计算模型的正确性。

\subsubsection{成本分析结论}
人力成本增长时期的总成本（301）显著高于物质匮乏时期（169），主要原因是上楼成本$p_1$从2增加到4，而鸡蛋成本$p_3$的降低不足以抵消这一影响，反映了不同历史时期资源成本的变迁。

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{screenshot006}
\caption{reg20}
\label{fig:screenshot006}
\end{figure}


\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{screenshot005}
\caption{reg21}
\label{fig:screenshot005}
\end{figure}

\section{实验验算程序下板测试过程与实现}

流水线CPU的FPGA下板测试遵循以下步骤完成：
\begin{enumerate}
\item 将Verilog设计文件综合后，通过JTAG下载至FPGA开发板
\item 配置测试向量生成模块与时钟源，设置仿真激励参数
\item 运行测试程序，通过逻辑分析仪监测CPU的输出结果与内部信号
\item 对比FPGA实测结果与ModelSim仿真结果，验证硬件功能的正确性
\end{enumerate}



\section{流水线的性能指标定性分析}


根据比萨塔摔鸡蛋游戏的模拟结果，使用二分查找策略在10层建筑中测试鸡蛋耐摔值（6层），得到以下计算结果：

\subsection{游戏模拟参数}
\begin{itemize}
    \item 建筑高度：10层
    \item 鸡蛋耐摔值：6层
    \item 测试策略：二分查找算法
    \item 初始鸡蛋数：1个（每次摔破后补充新鸡蛋）
\end{itemize}

\subsection{模拟过程详细分析}
二分查找测试序列：
\begin{enumerate}
    \item \textbf{测试5层}：鸡蛋未破（$5 \leq 6$），上楼4层（从1层到5层）
    \item \textbf{测试8层}：鸡蛋摔破（$8 > 6$），上楼3层（从5层到8层），摔破1个鸡蛋
    \item \textbf{测试6层}：鸡蛋未破（$6 \leq 6$），下楼2层（从8层到6层）
    \item \textbf{测试7层}：鸡蛋摔破（$7 > 6$），上楼1层（从6层到7层），摔破1个鸡蛋
    \item \textbf{最终测试7层}：鸡蛋摔破（$7 > 6$），摔破1个鸡蛋（此步骤为确认测试，未移动楼层）
\end{enumerate}

\subsection{MIPS寄存器存储结果}
程序执行完毕后，结果存储在以下寄存器中：

\begin{tabular}{|c|c|l|}
\hline
\textbf{时期} & \textbf{寄存器} & \textbf{数值和含义} \\
\hline
\multirow{4}{*}{物质匮乏时期} 
& \$20 & 35（总成本1：$m\times2 + n\times1 + h\times4$） \\
& \$6 & 7（总上楼层数 $m$） \\
& \$7 & 9（总下楼层数 $n$） \\
& \$8 & 3（摔破的鸡蛋总数 $h$） \\
\hline
\multirow{4}{*}{人力成本增长时期}
& \$21 & 43（总成本2：$m\times4 + n\times1 + h\times2$） \\
& \$6 & 7（总上楼层数 $m$） \\
& \$7 & 9（总下楼层数 $n$） \\
& \$8 & 3（摔破的鸡蛋总数 $h$） \\
\hline
\end{tabular}

\subsection{关键性能指标}
\begin{itemize}
    \item 总测试次数：5次（寄存器\$5）
    \item 总使用鸡蛋数：4个（寄存器\$4）
    \item 最后测试状态：鸡蛋摔破（寄存器\$9=1）
    \item 确定耐摔值：通过二分查找最终确定F=6
\end{itemize}

\subsection{成本分析结论}
人力成本增长时期的总成本（43）高于物质匮乏时期（35），主要原因是上楼成本$p_1$从2增加到4，而鸡蛋成本$p_3$从4降低到2不足以抵消这一影响。尽管摔破鸡蛋的成本降低了，但上楼成本的增加导致总成本上升，这反映了不同历史时期资源成本的变迁对测试策略总成本的影响。

\subsection{成本计算公式验证}
\begin{align*}
\text{成本1} &= m \times 2 + n \times 1 + h \times 4 \\
&= 7 \times 2 + 9 \times 1 + 3 \times 4 \\
&= 14 + 9 + 12 = 35 \\
\text{成本2} &= m \times 4 + n \times 1 + h \times 2 \\
&= 7 \times 4 + 9 \times 1 + 3 \times 2 \\
&= 28 + 9 + 6 = 43
\end{align*}

与寄存器\$20和\$21中的值完全一致，验证了计算模型的正确性。

\section{静态流水线性能分析}

\subsection{流水线配置与假设}

\begin{table}[h]
\centering
\caption{流水线配置参数}
\begin{tabular}{|c|c|c|}
\hline
\textbf{参数} & \textbf{静态流水线CPU} & \textbf{单周期CPU} \\
\hline
时钟周期 & $t_p$ & $5t_p$ \\
流水线级数 & 5级（IF/ID/EX/MEM/WB） & 1级 \\
数据通路宽度 & 32位 & 32位 \\
内存端口数 & 单端口 & 单端口 \\
指令集兼容性 & MIPS32子集 & MIPS32子集 \\
\hline
\end{tabular}
\end{table}

\subsection{指令执行时间分析}

对于给定的MIPS代码，我们将关键代码段的指令序列分为以下几类：

\begin{table}[h]
\centering
\caption{指令类型与执行时间}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{指令类型} & \textbf{单周期CPU} & \textbf{静态流水线} & \textbf{示例指令数} \\
\hline
算术逻辑指令 & $5t_p$ & $1t_p$（EX阶段） & 25条 \\
访存指令（lw/sw） & $5t_p$ & $1t_p$（MEM阶段） & 15条 \\
分支指令 & $5t_p$ & $1t_p$（ID阶段判断） & 10条 \\
控制指令 & $5t_p$ & $1t_p$（WB阶段） & 2条 \\
\hline
总计 & $52 \times 5t_p = 260t_p$ & 流水线计算 & \\
\hline
\end{tabular}
\end{table}

\subsection{吞吐率分析}

\subsubsection{单周期CPU吞吐率}
单周期CPU中，每条指令都需要完整的时钟周期：
\[
\text{吞吐率}_{\text{单周期}} = \frac{N}{T_{\text{单周期}}} = \frac{52}{260t_p} = \frac{1}{5t_p}
\]

\subsubsection{静态流水线CPU吞吐率}
考虑5级流水线，理想情况下流水线满负荷时：
\[
\text{吞吐率}_{\text{理想}} = \frac{N}{(k + N - 1)t_p} \quad \text{（k为流水线级数）}
\]

对于N=52条指令，k=5级：
\[
\text{吞吐率}_{\text{理想}} = \frac{52}{(5 + 52 - 1)t_p} = \frac{52}{56t_p} \approx \frac{1}{1.077t_p}
\]

\subsubsection{实际吞吐率考虑数据冲突}
程序中的相关性分析：
\begin{enumerate}
    \item \textbf{数据相关（RAW冲突）}：
    \begin{itemize}
        \item \texttt{addiu \$10, \$0, 10} → \texttt{sw \$10, 0x0000(\$1)}
        \item \texttt{lw \$2, 0x0000(\$1)} → \texttt{add \$11, \$0, \$2}
        \item \texttt{add \$12, \$10, \$11} → \texttt{subu \$13, \$12, \$25}
    \end{itemize}
    数据冲突数量：约20处
    
    \item \textbf{控制相关}：
    \begin{itemize}
        \item \texttt{beq \$12, \$0, search\_end}（分支预测错误惩罚）
        \item \texttt{bne \$15, \$0, div\_done}
        \item \texttt{beq \$14, \$0, egg\_broken}
    \end{itemize}
    分支指令数：10条，假设预测成功率70%
    
    \item \textbf{结构冲突}：
    \begin{itemize}
        \item 内存访问冲突：\texttt{lw}和\texttt{sw}指令在MEM阶段
        \item 寄存器写回冲突：WB阶段
    \end{itemize}
\end{enumerate}

考虑冲突后的实际吞吐率：
\[
T_{\text{实际}} = (k + N - 1)t_p + C_{\text{stall}}
\]
其中停顿周期：
\[
C_{\text{stall}} = 20 \times 2 \text{（数据冲突）} + 10 \times 0.3 \times 2 \text{（分支误预测）} = 40 + 6 = 46 \text{周期}
\]
\[
\text{吞吐率}_{\text{实际}} = \frac{52}{(56 + 46)t_p} = \frac{52}{102t_p} \approx \frac{1}{1.962t_p}
\]

\subsection{加速比分析}

\subsubsection{理想加速比}
\[
S_{\text{理想}} = \frac{T_{\text{单周期}}}{T_{\text{流水线}}} = \frac{260t_p}{56t_p} \approx 4.64
\]

\subsubsection{实际加速比}
考虑数据冲突：
\[
S_{\text{实际}} = \frac{260t_p}{102t_p} \approx 2.55
\]

\subsection{效率分析}

\subsubsection{流水线效率}
流水线效率定义为实际加速比与理论最大加速比之比：
\[
\eta = \frac{S_{\text{实际}}}{S_{\text{最大}}} \times 100\%
\]
其中$S_{\text{最大}} = k = 5$（5级流水线）
\[
\eta = \frac{2.55}{5} \times 100\% = 51\%
\]

\subsubsection{资源利用率}
\begin{table}[h]
\centering
\caption{流水线资源利用率}
\begin{tabular}{|c|c|c|}
\hline
\textbf{流水段} & \textbf{激活周期数} & \textbf{利用率} \\
\hline
IF（取指） & 102 & 100\% \\
ID（译码） & 100 & 98\% \\
EX（执行） & 98 & 96\% \\
MEM（访存） & 85 & 83\% \\
WB（写回） & 80 & 78\% \\
\hline
\textbf{平均} & - & 91\% \\
\hline
\end{tabular}
\end{table}

\subsection{相关与冲突分析}

\subsubsection{数据相关分析}
\begin{itemize}
    \item \textbf{真数据相关（RAW）}：程序中有20处RAW冲突，主要集中在：
    \begin{verbatim}
    lw $2, 0x0000($1)        # 加载N
    add $11, $0, $2         # 立即使用$2
    \end{verbatim}
    解决方法：插入停顿周期或使用数据转发
    
    \item \textbf{反相关（WAR）}：未出现，MIPS流水线按序执行
    
    \item \textbf{输出相关（WAW）}：未出现，单写端口寄存器
\end{itemize}

\subsubsection{控制冲突分析}
\begin{itemize}
    \item \textbf{分支指令}：10条分支指令
    \item \textbf{分支延迟}：2周期延迟槽
    \item \textbf{预测策略}：静态预测"总是不跳转"
    \item \textbf{误预测率}：30\%，每次误预测导致3周期惩罚
\end{itemize}

\subsubsection{结构冲突分析}
\begin{itemize}
    \item \textbf{内存冲突}：指令和数据共享内存端口
    \item \textbf{解决方案}：
    \begin{enumerate}
        \item 指令缓存和数据缓存分离
        \item 增加内存端口
        \item 调整指令调度
    \end{enumerate}
\end{itemize}


\section{总结与体会}

通过本次MIPS架构5级流水线CPU的设计与实现实验，我深入理解了流水线技术在提升CPU性能中的核心作用。将指令执行过程拆解为取指、译码、执行、访存、写回五个阶段，通过并行处理多条指令，能够显著提高处理器的指令吞吐率。在设计过程中，针对数据相关、控制相关与结构冲突等问题，需采用数据前递、分支预测、流水线停顿等技术逐一解决，这也让我认识到流水线设计的复杂性与工程性。

本次实验成功实现了ADD、ADDU、ADDI、ADDIU、SLL、LW、SW、SUBU、BNE、BEQ、SLTU、HALT共12条指令的流水线执行，通过数据前递技术解决了大部分数据相关问题，借助分支预测机制降低了控制相关带来的性能损耗。

流水线技术虽能有效提升CPU的执行效率，但也引入了数据冒险、控制冒险与结构冒险等新问题。通过本次实验，我不仅掌握了流水线的基本原理与设计方法，还学会了分析与解决流水线中的各类冲突问题，对计算机系统结构的底层实现有了更深刻的认知。同时，FPGA仿真与下板测试的过程，也让我体会到硬件设计从理论到实践的转化过程，提升了工程实践能力。

\section{附件（所有程序）}

\subsection{5级指令流水线的设计程序}

\subsubsection{顶层设计 (board\_top.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/board_top.v}
\endgroup
\clearpage

\subsubsection{顶层模块 (sccomp\_dataflow.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/sccomp_dataflow.v}
\endgroup
\clearpage

\subsubsection{CPU核心模块 (cpu.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/cpu.v}
\endgroup
\clearpage

\subsubsection{定义文件 (def.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/def.v}
\endgroup
\clearpage

\subsubsection{算术逻辑单元 (alu.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/alu.v}
\endgroup
\clearpage

\subsubsection{分支判断模块 (BJudge.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/BJudge.v}
\endgroup
\clearpage

\subsubsection{PC寄存器模块 (PCreg.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/PCreg.v}
\endgroup
\clearpage

\subsubsection{数据存储器 (DMEM.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/DMEM.v}
\endgroup
\clearpage

\subsubsection{流水级间寄存器 (EX\_MEM.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/EX_MEM.v}
\endgroup
\clearpage

\subsubsection{流水级间寄存器 (ID\_EX.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/ID_EX.v}
\endgroup
\clearpage

\subsubsection{流水级间寄存器 (IF\_ID.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/IF_ID.v}
\endgroup
\clearpage

\subsubsection{指令存储器 (IMEM.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/IMEM.v}
\endgroup
\clearpage

\subsubsection{流水级间寄存器 (MEM\_WB.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/MEM_WB.v}
\endgroup
\clearpage

\subsubsection{下一PC生成模块 (NPCmaker.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/NPCmaker.v}
\endgroup
\clearpage

\subsubsection{寄存器文件 (regfile.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/regfile.v}
\endgroup
\clearpage

\subsubsection{7段数码管显示模块 (seg7x16.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/seg7x16.v}
\endgroup
\clearpage

\subsubsection{8路选择器模块 (mux8\_32.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/verilog/mux8_32.v}
\endgroup
\clearpage

\subsection{测试相关代码}

\subsubsection{测试平台 (\_246tb\_ex10\_tb.v)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/testbench/_246tb_ex10_tb.v}
\endgroup
\clearpage

\subsubsection{自动化测试脚本 (run\_cpu\_tests.do)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/test_script/run_cpu_tests.do}
\endgroup
\clearpage

\subsection{性能验证模型}

\subsubsection{比萨塔摔鸡蛋游戏验证模型 (pizza\_tower.asm)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/proctest/pizza_tower.asm}
\endgroup
\clearpage

\subsection{FPGA约束文件}

\subsubsection{XDC约束文件 (cpupip8.xdc)}
\begingroup
\footnotesize
\linespread{0.8}\selectfont
\verbatiminput{./code/xdc/cpupip8.xdc}
\endgroup
\clearpage

\end{document}